import java.sql.*;

public class swing_20_jdbc {
    // JDBC URL, username, and password of MySQL server
    private static final String URL = "jdbc:mysql://localhost:3306/emp";
    private static final String USER = "root";
    private static final String PASSWORD = "msdhruv145";

    public static void main(String[] args) {
        try {

            // Step 0: Load MySQL JDBC Driver
            Class.forName("com.mysql.jdbc.Driver");

            // Step 1: Establishing a Connection
            // A Connection is a session between a Java application and a database. It helps
            // to establish a connection with the database.

            // The Connection interface is a factory of Statement, PreparedStatement, and
            // DatabaseMetaData, i.e., an object of Connection can be used to get the object
            // of Statement and DatabaseMetaData. The Connection interface provide many
            // methods for transaction management like commit(), rollback(),
            // setAutoCommit(), setTransactionIsolation(), etc.
            Connection connection = DriverManager.getConnection(URL, USER, PASSWORD);
            System.out.println("Connected to the database.");

            // Step 2: Creating a Statement
            // A Statement is an interface that provides methods to execute queries with the
            // database.
            Statement statement = connection.createStatement();

            // Step 3: Create the Cars table
            String createTableSQL = "CREATE TABLE IF NOT EXISTS Cars ("
                    + "id INT AUTO_INCREMENT PRIMARY KEY, "
                    + "brand VARCHAR(50) NOT NULL, "
                    + "model VARCHAR(50) NOT NULL, "
                    + "founded_in INT NOT NULL)";

            statement.executeUpdate(createTableSQL);
            System.out.println("Table 'Cars' created successfully.");

            // Step 4: Insert data into the Cars table
            String insertSQL = "INSERT INTO Cars (brand, model, founded_in) VALUES (?, ?, ?)";

            // The PreparedStatement interface is a subinterface of Statement. It is used to
            // execute parameterized query
            // It improves performance as it is precompiled only once and can be used
            // multiple times.
            PreparedStatement preparedStatement = connection.prepareStatement(insertSQL);
            preparedStatement.setString(1, "Ford");
            preparedStatement.setString(2, "Mustang");
            preparedStatement.setInt(3, 1964);

            preparedStatement.executeUpdate();
            System.out.println("Data inserted successfully into 'Cars' table.");

            // Step 5: Query data from the Cars table
            String selectSQL = "SELECT * FROM Cars";

            // ResultSet is a table of data representing a database result set, which is usually
            // generated by executing a statement that queries the database.

            // A ResultSet object maintains a cursor pointing to its current row of data.
            // Initially the cursor is positioned before the first row. The next method
            // moves the cursor to the next row, and because it returns false when there are
            // no more rows in the ResultSet object, it can be used in a while loop to
            // iterate through the result set.

            // A default ResultSet object is not updatable and has a cursor that moves
            // forward only. Thus, you can iterate through it only once and only from the
            // first row to the last row.
            ResultSet resultSet = statement.executeQuery(selectSQL);

            System.out.println("Querying data from 'Cars' table:");
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String brand = resultSet.getString("brand");
                String model = resultSet.getString("model");
                int foundedIn = resultSet.getInt("founded_in");
                System.out.println("ID: " + id + ", Brand: " + brand + ", Model: " + model + ", Founded In: " + foundedIn);
            }
            
            // To create a ResultSet object that is scrollable we can pass 
            // ResultSet.TYPE_SCROLL_INSENSITIVE or ResultSet.TYPE_SCROLL_SENSITIVE to the createStatement() method.
            // TYPE_SCROLL_INSENSITIVE: The result set is scrollable but not sensitive to changes in the database.
            // TYPE_SCROLL_SENSITIVE: The result set is scrollable and sensitive to changes in the database.
            // here sensitivity means if the data in the database changes, the result set will reflect those changes.
            // By default, the result set is not scrollable.
            PreparedStatement preparedStatement2 = connection.prepareStatement(selectSQL,ResultSet.TYPE_SCROLL_INSENSITIVE);

            
            // To make the ResultSet object updatable, we can pass ResultSet.CONCUR_UPDATABLE to the createStatement() method.
            // By default, the result set is not updatable.
            PreparedStatement preparedStatement3 = connection.prepareStatement(selectSQL,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
            ResultSet resultSetSU = preparedStatement3.executeQuery(selectSQL);
            
            // To update the data in the ResultSet object, we can use the updateXXX() method of the ResultSet interface.
            // The updateXXX() method is used to update the value of a column in the current row of the ResultSet object.
            // For example, the updateString() method is used to update the value of a column of type VARCHAR or TEXT.

            // To reflect the changes in the database, we need to call the updateRow() method after updating the data in the ResultSet object.
            // The cancelRowUpdates() method is used to cancel the updates made to the current row of the ResultSet object.
            // The deleteRow() method is used to delete the current row of the ResultSet object.

            // Step 7: Clean-up environment
            resultSet.close();
            statement.close();
            connection.close();

        } catch (SQLException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        } catch (Exception e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }
}
